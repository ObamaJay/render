import os
import re
import datetime
import tempfile
import traceback

import requests
import stripe
from flask import Flask, request, jsonify
from supabase import create_client
from fpdf import FPDF

# ---------------- Flask app ----------------
app = Flask(__name__)

# ---------------- Environment ----------------
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY", "")
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET", "")

SUPABASE_URL = os.getenv("SUPABASE_URL", "")
SUPABASE_SERVICE_ROLE_KEY = os.getenv("SUPABASE_SERVICE_ROLE_KEY", "")

RESEND_API_KEY = os.getenv("RESEND_API_KEY", "")
FROM_EMAIL = os.getenv("FROM_EMAIL", "onboarding@resend.dev")

TABLE_NAME = os.getenv("TABLE_NAME", "leads")
BUCKET = os.getenv("BUCKET", "casefiles")

# ---------------- Clients ----------------
stripe.api_key = STRIPE_SECRET_KEY
supabase = create_client(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)

# ---------------- Text helpers ----------------
CTRL_RE = re.compile(r"[\x00-\x08\x0B\x0C\x0E-\x1F]")  # strip control chars (keep \t \n \r)

def strip_non_latin1(text: str) -> str:
    return (text or "").encode("latin1", "ignore").decode("latin1")

def normalize_spaces(s: str) -> str:
    # NBSP ‚Üí space, tabs ‚Üí single space, drop control chars, soften long runs of dashes/underscores
    s = (s or "").replace("\xa0", " ").replace("\t", " ")
    s = CTRL_RE.sub("", s)
    s = re.sub(r"([-‚Äì‚Äî_])\1{9,}", lambda m: " ".join([m.group(1)*10] * (len(m.group(0)) // 10 + 1)), s)
    return s

def soften_long_tokens(s: str, max_len: int = 40) -> str:
    """Insert spaces inside any run of non‚Äëwhitespace longer than max_len so FPDF can wrap."""
    def chunker(w: str) -> str:
        return " ".join(w[i:i + max_len] for i in range(0, len(w), max_len))
    # Break URLs first
    s = re.sub(r"(https?://\S+)", lambda m: chunker(m.group(0)), s)
    # Then any long token
    return re.sub(r"\S{" + str(max_len) + r",}", lambda m: chunker(m.group(0)), s)

def sanitize_text(text: str) -> str:
    t = strip_non_latin1(text or "")
    t = normalize_spaces(t)
    t = soften_long_tokens(t, max_len=40)
    return t

# ---------------- PDF helpers (polished) ----------------
def add_cover_page(pdf: FPDF, visa_type: str, petitioner: str, beneficiary: str):
    pdf.add_page()
    pdf.set_margins(left=15, top=18, right=15)
    pdf.set_auto_page_break(auto=True, margin=15)

    # Title
    pdf.set_font("Arial", "B", 18)
    pdf.cell(0, 12, "ImmigrAI ‚Äì USCIS Case Checklist", ln=1, align="C")

    pdf.set_font("Arial", "", 12)
    pdf.ln(6)
    pdf.cell(0, 8, f"Visa Type: {sanitize_text(visa_type or 'N/A')}", ln=1, align="C")
    pdf.cell(0, 8, f"Petitioner: {sanitize_text(petitioner or 'N/A')}", ln=1, align="C")
    if beneficiary:
        pdf.cell(0, 8, f"Beneficiary: {sanitize_text(beneficiary)}", ln=1, align="C")

    pdf.ln(10)
    pdf.set_font("Arial", "", 10)
    pdf.multi_cell(0, 6,
        "This checklist was generated using publicly available USCIS guidance. "
        "It is intended for informational purposes only and does not constitute legal advice."
    )

def safe_multicell(pdf: FPDF, line: str, line_height: float, avail_w: float):
    """
    Try multi_cell; if fpdf still complains, fall back to fixed-size cell chunks.
    """
    try:
        pdf.set_x(pdf.l_margin)  # ensure we start from the left margin
        pdf.multi_cell(w=avail_w, h=line_height, txt=line)
    except Exception:
        # Final fallback: hard chunk and write via non-wrapping cell
        chunk = 60
        i = 0
        while i < len(line):
            piece = line[i:i+chunk]
            pdf.set_x(pdf.l_margin)
            pdf.cell(w=avail_w, h=line_height, txt=piece, ln=1)
            i += chunk

def add_checklist_body(pdf: FPDF, raw_text: str):
    safe_text = sanitize_text(raw_text)
    pdf.add_page()
    pdf.set_margins(left=15, top=15, right=15)
    pdf.set_auto_page_break(auto=True, margin=15)

    pdf.set_font("Arial", "B", 14)
    pdf.cell(0, 10, "Detailed Checklist", ln=1)
    pdf.ln(2)

    pdf.set_font("Arial", "", 10)
    avail_w = pdf.w - pdf.l_margin - pdf.r_margin
    line_h = 6.5

    # Keep original line breaks but beautify bullets/numbers if present
    lines = safe_text.splitlines()
    for raw_line in lines:
        line = sanitize_text(raw_line)
        safe_multicell(pdf, line, line_h, avail_w)

def add_footer(pdf: FPDF):
    pdf.set_y(-20)
    pdf.set_font("Arial", "", 9)
    pdf.set_text_color(120)
    pdf.cell(0, 6, "Generated by ImmigrAI.org ‚Äì Not affiliated with USCIS or the U.S. government.", ln=1, align="C")
    pdf.set_text_color(0)

def generate_pdf(text: str, visa_type: str, petitioner: str, beneficiary: str) -> str:
    """Create a polished PDF and return a temp file path."""
    pdf = FPDF()
    # Cover
    add_cover_page(pdf, visa_type, petitioner, beneficiary)
    # Body
    add_checklist_body(pdf, text)
    # Footer on last page
    add_footer(pdf)

    tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf")
    pdf.output(tmp.name)
    return tmp.name

# ---------------- Storage + Email ----------------
def upload_to_supabase(local_path: str, visa_type: str) -> tuple[str, str]:
    """
    Upload file to Supabase Storage and return (object_name, signed_url_24h).
    """
    ts = datetime.datetime.utcnow().strftime("%Y%m%d%H%M%S")
    object_name = f"{sanitize_text(visa_type or 'Checklist')}_{ts}.pdf"
    with open(local_path, "rb") as f:
        supabase.storage.from_(BUCKET).upload(object_name, f, {"content-type": "application/pdf"})
    signed = supabase.storage.from_(BUCKET).create_signed_url(object_name, 86400)  # 24h
    return object_name, signed.get("signedURL", "")

def build_email_html(download_link: str, visa_type: str) -> str:
    html = f"""
<!DOCTYPE html>
<html>
  <body style="font-family: Arial, sans-serif; color:#333; line-height:1.6; max-width:600px; margin:auto; padding:20px; border:1px solid #eee; border-radius:8px;">
    <div style="text-align:center; margin-bottom:20px;">
      <img src="https://immigrai.org/logo.png" alt="ImmigrAI" style="height:50px;">
    </div>
    <h2 style="color:#2c3e50;">Your USCIS Checklist is Ready</h2>
    <p>Thank you for using <strong>ImmigrAI</strong>. We‚Äôve generated your personalized checklist for the <strong>{sanitize_text(visa_type)}</strong> visa type.</p>
    <div style="text-align:center; margin:30px 0;">
      <a href="{download_link}" style="background:#0070f3; color:white; text-decoration:none; padding:12px 20px; border-radius:6px; font-weight:bold;">
        üìÑ Download Your Checklist
      </a>
    </div>
    <p>This checklist is based on the latest USCIS requirements to help ensure you don‚Äôt miss any documents in your application.</p>
    <p style="margin-top:30px; font-size:14px; color:#777;">
      üí° Need help? Just reply to this email‚Äîwe‚Äôre here for you.<br>
      üîí 100% Money‚ÄëBack Guarantee if you‚Äôre not satisfied.
    </p>
    <hr style="margin:30px 0;">
    <p style="font-size:12px; color:#999; text-align:center;">
      Generated by ImmigrAI.org ‚Äì Your immigration assistant.<br>
      Not affiliated with USCIS or the U.S. government.
    </p>
  </body>
</html>
"""
    return html

def build_email_text(download_link: str, visa_type: str) -> str:
    return (
        f"Your USCIS Checklist is Ready ‚Äì {sanitize_text(visa_type)}\n\n"
        "Thank you for using ImmigrAI. We‚Äôve generated your personalized checklist.\n\n"
        f"Download here: {download_link}\n\n"
        "This checklist is based on the latest USCIS requirements.\n"
        "Need help? Reply to this email.\n"
        "100% Money‚ÄëBack Guarantee if you‚Äôre not satisfied.\n\n"
        "ImmigrAI.org ‚Äì Not affiliated with USCIS."
    )

def send_resend_email(to_email: str, petitioner: str, visa_type: str, signed_url: str) -> tuple[int, str]:
    html = build_email_html(signed_url, visa_type)
    text = build_email_text(signed_url, visa_type)
    payload = {
        "from": f"ImmigrAI <{FROM_EMAIL}>",
        "to": to_email,
        "subject": f"Your USCIS Checklist is Ready ‚Äì {sanitize_text(visa_type)}",
        "html": html,
        "text": text,
    }
    r = requests.post(
        "https://api.resend.com/emails",
        headers={"Authorization": f"Bearer {RESEND_API_KEY}", "Content-Type": "application/json"},
        json=payload,
        timeout=20,
    )
    return r.status_code, r.text

# ---------------- Health routes ----------------
@app.get("/")
def root():
    return "‚úÖ ImmigrAI webhook running", 200

@app.get("/webhook")
def webhook_info():
    return "Stripe webhook endpoint is alive. Send POST events from Stripe.", 200

# ---------------- Stripe webhook ----------------
@app.post("/webhook")
def stripe_webhook():
    # Sanity check env
    missing = [k for k, v in {
        "STRIPE_SECRET_KEY": STRIPE_SECRET_KEY,
        "STRIPE_WEBHOOK_SECRET": STRIPE_WEBHOOK_SECRET,
        "SUPABASE_URL": SUPABASE_URL,
        "SUPABASE_SERVICE_ROLE_KEY": SUPABASE_SERVICE_ROLE_KEY,
        "RESEND_API_KEY": RESEND_API_KEY,
    }.items() if not v]
    if missing:
        print("‚ùå Missing env vars:", ", ".join(missing))
        return jsonify({"error": "missing_env", "details": missing}), 200

    payload = request.data
    sig = request.headers.get("Stripe-Signature", "")

    # 1) Verify signature
    try:
        event = stripe.Webhook.construct_event(payload, sig, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        print("‚ùå Signature verification failed:", e)
        return f"Invalid signature: {e}", 400

    event_type = event.get("type")
    print("‚úÖ Event type:", event_type)

    if event_type != "checkout.session.completed":
        return jsonify({"ignored": event_type}), 200

    pdf_path = None
    try:
        session = event["data"]["object"]
        email = (session.get("customer_details") or {}).get("email") or session.get("customer_email")
        print("Email from Stripe:", email)

        if not email:
            print("‚ö†Ô∏è No email present in session; cannot match lead.")
            return jsonify({"status": "no_email"}), 200

        # 2) Fetch most recent matching lead
        q = supabase.table(TABLE_NAME).select("*").eq("email", email).order("created_at", desc=True).limit(1).execute()
        found = bool(q.data)
        print("Lead found?", found)
        if not found:
            return jsonify({"status": "no_matching_lead"}), 200

        lead = q.data[0]
        text = lead.get("checklist_text") or ""
        petitioner = lead.get("petitioner_name") or "there"
        beneficiary = lead.get("beneficiary_name") or ""
        visa_type = lead.get("visa_type") or "Checklist"

        print("Generating PDF for visa_type:", visa_type)

        # 3) Generate polished PDF
        pdf_path = generate_pdf(text, visa_type, petitioner, beneficiary)

        # 4) Upload + 24h signed URL
        object_name, signed_url = upload_to_supabase(pdf_path, visa_type)
        print("Uploaded object:", object_name)
        print("Signed URL (truncated):", (signed_url or "")[:120], "...")

        # 5) Email customer
        status, body = send_resend_email(email, petitioner, visa_type, signed_url)
        print("Resend status:", status, body[:200])

        # 6) Write back to lead (object name + timestamp)
        try:
            supabase.table(TABLE_NAME).update({
                "pdf_object": object_name,
                "emailed_at": datetime.datetime.utcnow().isoformat()
            }).eq("email", email).order("created_at", desc=True).limit(1).execute()
        except Exception as e:
            print("‚ö†Ô∏è Could not update lead with pdf_object/emailed_at:", e)

        return jsonify({"ok": True}), 200

    except Exception as e:
        print("üí• Handler error:", repr(e))
        traceback.print_exc()
        # Return 200 so Stripe doesn‚Äôt retry forever; logs will show the exact issue
        return jsonify({"error": str(e)}), 200
    finally:
        if pdf_path:
            try:
                os.unlink(pdf_path)
            except Exception:
                pass

# Local run (Render uses gunicorn with `gunicorn webhook:app`)
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
